# Procesamiento de flujos

En esta parte supondremos que los datos se pueden representar como un flujo de tal velocidad y volumen que típicamente no es posible almacenar todo el flujo, o que no es posible hacer queries a la base de datos resultante.

Veremos técnicas simples para obtener resúmenes simples de los flujos, y también veremos cómo aplicar métodos probabilísticos para filtrar o resumir ciertos aspectos de estos flujos.

Ejemplos de flujos son datos de sitios de internet, datos de redes grandes de sensores, datos de transacciones.

## Muestreo y restricción temporal

Para analizar flujos con estas propiedades podemos hacer:

- Restricción temporal: considerar ventanas de tiempo, y hacer análisis sobre los últimos datos en la ventana. Datos nuevos van reemplazando a datos anteriores, y puede ser que los datos anteriores no se respaldan (o es costoso acceder a ellos).

- Resúmenes acumulados: guardamos resúmenes de los datos que podemos actualizar y utilizar para calcular características de interés en el sistema, por ejemplo conteos simples, promedios.

- Muestreo y filtrado: filtros y muestreo probabilístico. Podemos diseñar muestras apropiadas para estimar cantidades que nos interesen, y sólo guardar los datos que corresponden a la muestra.

Nos interesan principalmente las técnicas de este último punto. Consideraremos dos problemas:

- *Filtrar un flujo*: En general, ¿cómo retener para análisis elementos del flujo que satisfagan una propiedad?
- *Muestreo de un flujo*: ¿Cómo diseñar un esquema de muestreo apropiado?
- *Ventanas resumen*

## Selección de muestra y funciones hash.

Dependiendo de las unidades de muestreo apropiadas que nos
interesen (por ejemplo, clientes o usuarios, transacciones, etc.)
podemos diseñar distintas estrateginas

### Ejemplo {-}
Si queremos estimar el promedio del tamaño de las transacciones en una ventana de tiempo dada, podemos muestrar esa ventana. Cada vez que llega una transacción, usamos un número aleatorio para decidir si
lo incluimos en la muestra o no, y luego hacer nuestro análisis
con las unidades seleccionadas.

```{r, message = FALSE, warning = FALSE}
library(iterators)
library(tidyverse)
```

```{r}
generar_trans <- function(){
  id_num <- sample.int(500, 1)
  monto <- runif(1, 100,10000) + id_num*10
  trans <- list(id = id_num, monto = monto)
}
```

Podemos estimar la mediana con toda la muestra. Primero generamos
durante 2 segundos, y calculamos la mediana de las transacciones:

```{r}
set.seed(32)
a <- timeout(generar_trans, 2) %>% as.list
length(a)
sapply(a, function(elem) elem$monto) %>% median
```


Si queremos seleccionar un 1\% de las transacciones, 


```{r}
seleccionar_rng <- function(trans){
   runif(1) < 0.01
}
trans_filtradas <- iter(generar_trans, seleccionar_rng)
b <- timeout(trans_filtradas, 2) %>% as.list
length(b)
sapply(b, function(elem) elem$monto) %>% median
```

---



### Ejemplo {-}
Ahora supongamos que queremos estimar el promedio (por cliente) de la transacción máxima de los clientes en una ventana de tiempo. En este caso, la unidad de muestreo más simple es el cliente, y el método del ejemplo anterior es menos apropiado. Quisiéramos en lugar de eso tomar una muestra de
clientes en la ventana, tomar el máximo de todas sus transacciones,
y luego promediar. 

- En este caso, el análisis es más complicado si seleccionamos cada transacción según un número aleatorio (tenderíamos a seleccionar más clientes con muchas transacciones).

```{block2, type ='resumen'}
Podemos usar una función hash del **identificador único de cliente**, y mapear a un cierto número de cubetas $1,\to B$.
Los clientes de la meustra son los que caen en una cubeta (por ejemplo la cubeta 1), y así 
obtendríamos una muestra que consiste de $1/B$ de los clientes
totales que tuvieron actividad en la ventana de interés-
```

- Todos los clientes que tuvieron actividad en la ventana tienen la misma probabilidad de ser seleccionados.
- No es necesario buscar en una lista si el cliente está en la muestra seleccionada o no (lo cual puede ser tardado, o puede ser que terminemos con muestras muy grandes o chicas).
- Este método incorpora progresivamente nuevos clientes a la lista muestreada. Por ejemplo, si la cantidad de clientes está creciendo,
entonces el número de clientes muestreados crecerá de manera correspondiente.



```{r}
a <- timeout(generar_trans, 2) %>% as.list
length(a)
df <- bind_rows(a)
df %>% group_by(id) %>% summarise(monto_max = max(monto)) %>%
  pull(monto_max) %>% median
```

```{r}
seleccionar <- function(trans){
  (21*trans$id %% 23 %% 10) == 0
}
trans_filtradas_cliente <- iter(generar_trans, seleccionar)
b <- timeout(trans_filtradas_cliente, 2) %>% as.list
length(b)
df <- bind_rows(b)
df %>% group_by(id) %>% summarise(monto_max = max(monto)) %>%
  pull(monto_max) %>% median
```


Sin emgargo, esto no funciona con el método de seleccion de arriba:

```{r}
trans_filtradas_cliente <- iter(generar_trans, seleccionar_rng)
b <- timeout(trans_filtradas_cliente, 2) %>% as.list
length(b)
df <- bind_rows(b)
df %>% group_by(id) %>% summarise(monto_max = max(monto)) %>%
  pull(monto_max) %>% median
```

**Observación**: en este último ejemplo, para cada usuario sólo
muestreamos una fracción de sus transacciones. En algunos casos, 
no muestreamos el máximo, y esto produce que la estimación 
esté sesgada hacia abajo.



## Selección de muestra bajo identificadores fijos.

En algunos casos, podemos tener un conjunto $S$ de unidades
que seleccionamos con anterioridad, y quisiéramos seleccionar
en la muestra los datos relacionados con elementos en ese conjunto.

Por ejemplo, quizá nos interesaría muestrar las transacciones
que se hacen en comercios donde han existido fraudes anterioremente,
o quizá checar si un correo proviene de una dirección que está 
en una whitelist (o blacklist)

En estos ejemplo, 
tenemos que checar contra la lista $S$ si seleccionamos un elemento o no, a
diferencia de los ejemplos de arriba.
Cuando la lista es muy grande, esta operación puede ser costosa. Podemos usar 
una estructura indexada (por ejemplo en una base de datos), pero
hay buenas alternativas con desempeño excelente en tiempo y memoria
de tipo probabilístico.

### Ejemplos {-}

- [Este es un ejemplo](https://gallery.shinyapps.io/087-crandash/) de una
aplicación que cuenta el número de usuarios únicos que bajan paquetes de CRAN. Cada
vez que hay una nueva descarga (transacción) debemos decidir si se trata
de usuarios nuevos o no y actualizar correctamente el conteo de usuarios únicos.

- Supongamos que tenemos un diccionario de palabras $S$ del español.
Cuando observamos una nueva "palabra" que alguien escribió,
queremos saber si la palabra está en el diccionario. Por ejemplo,
para decidir si es un posible error de ortografía o proponer algún sustituto.

- Decidir si una dirección web está en una lista negra, para dar una advertencia
inmediata (*safe browsing*).

---

Una solución a este problema es el filtro de bloom, que es
un esquema probabilístico para filtrar elementos de un flujo
que pertenecen a una colección fija $S$.

## Filtro de Bloom

Consideremos entonces el problema de filtrar de un flujo solamente los elementos que pertenezcan a un conjunto S.

Un filtro de Bloom consiste de:

- Un conjunto $\Omega$ de posibles valores (el universo) que puede aprecer en el flujo
- Un subconjunto $S\subset \Omega$
 de valores que están en la muestra.
- Un vector $v$ de $n$ bits, originalmente igual a 0.
- Una colección de funciones hash $h_1,h_2,\ldots, h_k$ escogidos al azar,
que mapean elementos de $\Omega$ a $n$ cubetas.
 
Queremos decidir si un elemento nuevo $\omega\in \Omega$ está o no en el
conjunto $S.


### Ejemplos {-}

- [Medium](https://blog.medium.com/what-are-bloom-filters-1ec2a50c68ff) usa 



