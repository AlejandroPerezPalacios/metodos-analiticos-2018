# Similitud: Locality sensitive hashing

```{r, echo=FALSE, message=FALSE}
library(tidyverse)
cb_palette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```


En esta parte continuaremos con la búsqueda de pares similares
para colecciones de textos, y después mostraremos cómo aplicar
estas técnicas para otras medidas de distancia  (como distancia
euclideana y coseno). 

Como vimos en la parte anterior, la técnica de LSH (locality sensitive
hashing) consiste en poner en cubetas a elementos que tengan 
hashes similares. Si diseñamos correctamente el método, entonces
no es necesario hacer todas las comparaciones entre los pares,
y basta examinar los elementos que compartan cubeta con otros elementos
(eliminando la mayor parte de las cubetas que tendrán solo un elemento).


## Análisis de la técnica de bandas 

En la sección anterior dimos la primera idea como usar
la *técnica de bandas* con minhashes para encontrar documentos de similitud alta, con distintos umbrales de similitud alta. Aquí describimos un análisis
más detallado de la técncia

```{block2 , type='resumen'}
Supongamos que tenemos un total de $k$ minhashes, que dividimos
en $b$ bandas de tamaño $r$, de modo que $k=br$. 

- Decimos que un par de documentos *coinciden* en una banda de $r$ hashes
si coinciden en todos los hashes de esa banda.

- Un par de documentos es un **par candidato** si 
por al menos coinciden en una banda (es decir, en al menos dentro
de una banda todos los hashes coinciden).

```

Ahora vamos a calcular la probabilidad de que un par de documentos
con similitud $s$ sea un par candidato:

1. La probabilidad de que estos dos documentos coincidan en un hash
particular es $s$, la similitud de Jaccard.
2. La probabiliad de que todos los hashes de una banda coincidan es
$s^r$, pues seleccionamos los hashes independientemente. 
3. Así que la probabilidad de que los documentos no coincidan en una banda
particular es:
es $1-s^r$
4. Esto implica que la probabilidad de que los documentos no coincidan en ninguna banda es $(1-s^r)^b$.
5. Finalmente, la probabilidad de que estos dos documentos sea un par candidato es $1-(1-s^r)^b$, que es la probabilidad de que coincidan en al menos una banda.

```{block2, type='resumen'}
Si la similitud de jaccard de dos documentos es $s$, la probabilidad
de que sean un par candidato es igual a $$1-(1-s^r)^b$$.
```

### Ejemplo {-}
Supongamos que tenemos 8 minhashes, y que nos
interesa encontrar documentos con similitud mayor a 0.7. 
Tenemos las siguientes posiblidades:
```{r}
graficar_curvas <- function(df_br, colour = TRUE){
  r <- df_br$r
  b <- df_br$b
  datos_graf <- data_frame(s = seq(0, 1, 0.01))
  curvas_similitud <- data_frame(b = b, r =r) %>%
                    group_by(r, b) %>%
                    mutate(datos = map2(r, b, function(r, b){
                      datos_graf %>% 
                      mutate(prob = 1 - (1 - s ^ r) ^b)
                    })) %>%
                    unnest
  graf_salida <- ggplot(curvas_similitud, 
                        aes(x = s, y = prob, 
                            colour = as.factor(interaction(b,r)))) +
                 geom_line(size=1.2) + 
                 labs(x = 'similitud', y= 'probablidad de ser candidato',
                      colour = 'b.r') 
  if(colour){
    graf_salida + scale_colour_manual(values=cb_palette)
  }
                 
  graf_salida
}
r <- c(1,2,4,8)
df_br <- data_frame(r = r, b = rev(r))
graficar_curvas(df_br) + 
                 geom_vline(xintercept = 0.7)
```

- Con la configuración $r=8, b=1$ (un solo grupo de 8 hashes) es posible
que no capturemos muchos pares de la similitud que nos interesa.
- Con $r=1, b=8$ (al menos un hash de los 8), dejamos pasar 
demasiados falsos positivos, que después vamos a tener que filtrar.
- Los otros dos casos son mejores para nuestro propósito. $r=2$ produce falsos negativos que hay que filtrar, y para $r=4$ hay una probabilidad de alrededor de 50\%
de que no capturemos pares con similitud cercana a 0.7

Generalmente quisiéramos obtener algo más cercano a una función escalón.
Podemos acercarnos si incrementamos el número total de hashes.

```{r}
r <- c(4, 5, 8, 10, 20)
b <- 80/r
graficar_curvas(data_frame(b, r)) +
                 geom_vline(xintercept = 0.7) 
```

---

**Observación**: La curva alcanza probabilidad 1/2 cuando la similitud
es
$$s = \left (1-\left (0.5\right )^{1/b} \right )^{1/r}.$$
Y podemos usar esta fórmula para escoger valores de $b$ y $r$ apropiados,
dependiendo de que similitud nos interesa capturar (quizá moviendo un poco
hacia abajo si queremos tener menos falsos negativos).


### Ejemplo {-}

Supongamos que nos interesan documentos con similitud mayor a 0.5,
con 50 o 100 hashes:
Algunas combinaciones que podemos tratar son:

```{r}
num_hashes <- 50
params_umbral <- function(num_hashes, umbral_inf, umbral_sup){
  combinaciones_pr <- 
    data_frame(b=seq(1, num_hashes), 
               r = num_hashes %% seq(1, num_hashes)) %>%
  unique() %>%
  mutate(s = (1 - (0.5)^(1/b))^(1/r)) %>%
  filter(s < umbral_sup, s > umbral_inf)
}

combinaciones_50 <- params_umbral(50, 0.4, 0.5)
combinaciones_120 <- params_umbral(120, 0.4, 0.5)

graficar_curvas(combinaciones_50)
```

Con 120 hashes podemos obtener curvas con mayor pendiente:

```{r}
graficar_curvas(combinaciones_120)
```

**Observación**: La decisión de los valores para estos parámetros
debe balancear qué tan importante es tener pares no detectados,
y el cómputo necesario para calcular los hashes y filtrar los
falsos positivos.


## Resumen de LSH basado en minhashing

Resumen de [@mmd]

1. Escogemos un número $k$ de tamaño de tejas, y construimos el
conjunto de tejas de cada documento. Si es necesario las tejas
pueden hashearse a números de tamaño razonable.
2. Ordenar los pares documento-teja y agrupar por teja.
3. Escoger $n$, el número de minhashes. Aplicamos el algoritmo de la
clase anterior (teja por teja) para calcular las 
firmas minhash de todos los documentos.
4. Escoger el umbral $s$ de similitud que nos ineresa. Escogemos $b$ y $r$
(número de bandas y de qué tamaño), usando la fórmula de arriba hasta
obtener un valor cercano al umbral. 
Si es importante evitar falsos negativos, escoger valores de b y r que
den un umbral más bajo, si la velocidad es importante entonces escoger
para un umbral más alto y evitar falsos positivos.
5. Construir pares similares usando LSH
6. Examinar las firmas de cada par candidato y determinar si 
la fracción de coincidencias sobre todos los minhashes es satisfactorio.
Alternativamente (más preciso), calcular directamente la similitud 
de jaccard a partir de las tejas originales. 


